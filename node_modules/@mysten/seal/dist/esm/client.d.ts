import { G2Element } from './bls12381.js';
import type { DerivedKey, KeyServer } from './key-server.js';
import type { DecryptOptions, EncryptOptions, FetchKeysOptions, GetDerivedKeysOptions, SealClientExtensionOptions, SealClientOptions, SealCompatibleClient } from './types.js';
export declare class SealClient {
    #private;
    constructor(options: SealClientOptions);
    static asClientExtension(options: SealClientExtensionOptions): {
        name: "seal";
        register: (client: SealCompatibleClient) => SealClient;
    };
    /**
     * Return an encrypted message under the identity.
     *
     * @param kemType - The type of KEM to use.
     * @param demType - The type of DEM to use.
     * @param threshold - The threshold for the TSS encryption.
     * @param packageId - the packageId namespace.
     * @param id - the identity to use.
     * @param data - the data to encrypt.
     * @param aad - optional additional authenticated data.
     * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.
     * 	Since the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.
     */
    encrypt({ kemType, demType, threshold, packageId, id, data, aad, }: EncryptOptions): Promise<{
        encryptedObject: Uint8Array<ArrayBuffer>;
        key: Uint8Array<ArrayBuffer>;
    }>;
    /**
     * Decrypt the given encrypted bytes using cached keys.
     * Calls fetchKeys in case one or more of the required keys is not cached yet.
     * The function throws an error if the client's key servers are not a subset of
     * the encrypted object's key servers or if the threshold cannot be met.
     *
     * If checkShareConsistency is true, the decrypted shares are checked for consistency, meaning that
     * any combination of at least threshold shares should either succesfully combine to the plaintext or fail.
     * This is useful in case the encryptor is not trusted and the decryptor wants to ensure all decryptors
     * receive the same output (e.g., for onchain encrypted voting).
     *
     * @param data - The encrypted bytes to decrypt.
     * @param sessionKey - The session key to use.
     * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
     * @param checkShareConsistency - If true, the shares are checked for consistency.
     * @returns - The decrypted plaintext corresponding to ciphertext.
     */
    decrypt({ data, sessionKey, txBytes, checkShareConsistency }: DecryptOptions): Promise<Uint8Array<ArrayBufferLike>>;
    getKeyServers(): Promise<Map<string, KeyServer>>;
    /**
     * Get the public keys for the given services.
     * If all public keys are not in the cache, they are retrieved.
     *
     * @param services - The services to get the public keys for.
     * @returns The public keys for the given services in the same order as the given services.
     */
    getPublicKeys(services: string[]): Promise<G2Element[]>;
    /**
     * Fetch keys from the key servers and update the cache.
     *
     * It is recommended to call this function once for all ids of all encrypted objects if
     * there are multiple, then call decrypt for each object. This avoids calling fetchKey
     * individually for each decrypt.
     *
     * @param ids - The ids of the encrypted objects.
     * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
     * @param sessionKey - The session key to use.
     * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.
     */
    fetchKeys({ ids, txBytes, sessionKey, threshold }: FetchKeysOptions): Promise<void>;
    /**
     * Get derived keys from the given services.
     *
     * @param id - The id of the encrypted object.
     * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
     * @param sessionKey - The session key to use.
     * @param threshold - The threshold.
     * @returns - Derived keys for the given services that are in the cache as a "service object ID" -> derived key map. If the call is succesful, exactly threshold keys will be returned.
     */
    getDerivedKeys({ kemType, id, txBytes, sessionKey, threshold, }: GetDerivedKeysOptions): Promise<Map<string, DerivedKey>>;
}

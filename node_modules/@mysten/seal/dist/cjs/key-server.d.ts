import type { SealCompatibleClient } from './types.js';
import type { G1Element } from './bls12381.js';
import { Version } from './utils.js';
import type { Certificate } from './session-key.js';
export type KeyServer = {
    objectId: string;
    name: string;
    url: string;
    keyType: KeyServerType;
    pk: Uint8Array<ArrayBuffer>;
};
export declare enum KeyServerType {
    BonehFranklinBLS12381 = 0
}
export declare const SERVER_VERSION_REQUIREMENT: Version;
/**
 * Given a list of key server object IDs, returns a list of SealKeyServer
 * from onchain state containing name, objectId, URL and pk.
 *
 * @param objectIds - The key server object IDs.
 * @param client - The SuiClient to use.
 * @returns - An array of SealKeyServer.
 */
export declare function retrieveKeyServers({ objectIds, client, }: {
    objectIds: string[];
    client: SealCompatibleClient;
}): Promise<KeyServer[]>;
/**
 * Given a KeyServer, fetch the proof of possession (PoP) from the URL and verify it
 * against the pubkey. This should be used only rarely when the dapp uses a dynamic
 * set of key servers.
 *
 * @param server - The KeyServer to verify.
 * @returns - True if the key server is valid, false otherwise.
 */
export declare function verifyKeyServer(server: KeyServer, timeout: number, apiKeyName?: string, apiKey?: string): Promise<boolean>;
/**
 * Verify the key server version. Throws an `InvalidKeyServerError` if the version is not supported.
 *
 * @param response - The response from the key server.
 */
export declare function verifyKeyServerVersion(response: Response): void;
export interface DerivedKey {
    toString(): string;
}
/**
 * A user secret key for the Boneh-Franklin BLS12381 scheme.
 * This is a wrapper around the G1Element type.
 */
export declare class BonehFranklinBLS12381DerivedKey implements DerivedKey {
    key: G1Element;
    representation: string;
    constructor(key: G1Element);
    toString(): string;
}
/**
 * Options for fetching keys from the key server.
 */
export interface FetchKeysOptions {
    /** The URL of the key server. */
    url: string;
    /** The Base64 string of request signature. */
    requestSignature: string;
    /** The transaction bytes. */
    transactionBytes: Uint8Array;
    /** The ephemeral secret key. */
    encKey: Uint8Array<ArrayBuffer>;
    /** The ephemeral public key. */
    encKeyPk: Uint8Array<ArrayBuffer>;
    /** The ephemeral verification key. */
    encVerificationKey: Uint8Array;
    /** The certificate. */
    certificate: Certificate;
    /** Request timeout in milliseconds. */
    timeout: number;
    /** Optional API key name. */
    apiKeyName?: string;
    /** Optional API key. */
    apiKey?: string;
    /** Optional abort signal for cancellation. */
    signal?: AbortSignal;
}
/**
 * Helper function to request all keys from URL with requestSig, txBytes, ephemeral pubkey.
 * Then decrypt the Seal key with ephemeral secret key. Returns a list decryption keys with
 * their full IDs.
 *
 * @param url - The URL of the key server.
 * @param requestSig - The Base64 string of request signature.
 * @param txBytes - The transaction bytes.
 * @param encKey - The ephemeral secret key.
 * @param certificate - The certificate.
 * @returns - A list of full ID and the decrypted key.
 */
export declare function fetchKeysForAllIds({ url, requestSignature, transactionBytes, encKey, encKeyPk, encVerificationKey, certificate, timeout, apiKeyName, apiKey, signal, }: FetchKeysOptions): Promise<{
    fullId: string;
    key: Uint8Array<ArrayBuffer>;
}[]>;

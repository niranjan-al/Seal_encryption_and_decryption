import type { EncryptedObject } from './bcs.js';
import type { G1Element } from './bls12381.js';
import { G2Element } from './bls12381.js';
import type { KeyCacheKey } from './types.js';
export interface DecryptOptions {
    encryptedObject: typeof EncryptedObject.$inferType;
    keys: Map<KeyCacheKey, G1Element>;
    publicKeys?: G2Element[];
}
/**
 * Decrypt the given encrypted bytes with the given cached secret keys for the full ID.
 * It's assumed that fetchKeys has been called to fetch the secret keys for enough key servers
 * otherwise, this will throw an error.
 * Also, it's assumed that the keys were verified by the caller.
 *
 * If publicKeys are provided, the decrypted shares are checked for consistency, meaning that
 * any combination of at least threshold shares should either succesfully combine to the plaintext or fail.
 *
 * @returns - The decrypted plaintext corresponding to ciphertext.
 */
export declare function decrypt({ encryptedObject, keys, publicKeys, }: DecryptOptions): Promise<Uint8Array>;

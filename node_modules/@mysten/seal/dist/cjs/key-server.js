"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var key_server_exports = {};
__export(key_server_exports, {
  BonehFranklinBLS12381DerivedKey: () => BonehFranklinBLS12381DerivedKey,
  KeyServerType: () => KeyServerType,
  SERVER_VERSION_REQUIREMENT: () => SERVER_VERSION_REQUIREMENT,
  fetchKeysForAllIds: () => fetchKeysForAllIds,
  retrieveKeyServers: () => retrieveKeyServers,
  verifyKeyServer: () => verifyKeyServer,
  verifyKeyServerVersion: () => verifyKeyServerVersion
});
module.exports = __toCommonJS(key_server_exports);
var import_bcs = require("@mysten/bcs");
var import_bls12_381 = require("@noble/curves/bls12-381");
var import_bcs2 = require("./bcs.js");
var import_error = require("./error.js");
var import_ibe = require("./ibe.js");
var import_version = require("./version.js");
var import_utils = require("./utils.js");
var import_elgamal = require("./elgamal.js");
const EXPECTED_SERVER_VERSION = 1;
var KeyServerType = /* @__PURE__ */ ((KeyServerType2) => {
  KeyServerType2[KeyServerType2["BonehFranklinBLS12381"] = 0] = "BonehFranklinBLS12381";
  return KeyServerType2;
})(KeyServerType || {});
const SERVER_VERSION_REQUIREMENT = new import_utils.Version("0.4.1");
async function retrieveKeyServers({
  objectIds,
  client
}) {
  return await Promise.all(
    objectIds.map(async (objectId) => {
      const res = await client.core.getObject({
        objectId
      });
      const ks = import_bcs2.KeyServerMove.parse(await res.object.content);
      if (EXPECTED_SERVER_VERSION < Number(ks.firstVersion) || EXPECTED_SERVER_VERSION > Number(ks.lastVersion)) {
        throw new import_error.InvalidKeyServerVersionError(
          `Key server ${objectId} supports versions between ${ks.firstVersion} and ${ks.lastVersion} (inclusive), but SDK expects version ${EXPECTED_SERVER_VERSION}`
        );
      }
      const resVersionedKs = await client.core.getDynamicField({
        parentId: objectId,
        name: {
          type: "u64",
          bcs: import_bcs.bcs.u64().serialize(EXPECTED_SERVER_VERSION).toBytes()
        }
      });
      const ksVersioned = import_bcs2.KeyServerMoveV1.parse(resVersionedKs.dynamicField.value.bcs);
      if (ksVersioned.keyType !== 0 /* BonehFranklinBLS12381 */) {
        throw new import_error.InvalidKeyServerError(
          `Server ${objectId} has invalid key type: ${ksVersioned.keyType}`
        );
      }
      return {
        objectId,
        name: ksVersioned.name,
        url: ksVersioned.url,
        keyType: ksVersioned.keyType,
        pk: new Uint8Array(ksVersioned.pk)
      };
    })
  );
}
async function verifyKeyServer(server, timeout, apiKeyName, apiKey) {
  const requestId = crypto.randomUUID();
  const response = await fetch(server.url + "/v1/service?service_id=" + server.objectId, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Request-Id": requestId,
      "Client-Sdk-Type": "typescript",
      "Client-Sdk-Version": import_version.PACKAGE_VERSION,
      ...apiKeyName && apiKey ? { [apiKeyName]: apiKey } : {}
    },
    signal: AbortSignal.timeout(timeout)
  });
  await import_error.SealAPIError.assertResponse(response, requestId);
  verifyKeyServerVersion(response);
  const serviceResponse = await response.json();
  if (serviceResponse.service_id !== server.objectId) {
    return false;
  }
  const fullMsg = (0, import_utils.flatten)([import_ibe.DST_POP, server.pk, (0, import_bcs.fromHex)(server.objectId)]);
  return import_bls12_381.bls12_381.verifyShortSignature((0, import_bcs.fromBase64)(serviceResponse.pop), fullMsg, server.pk);
}
function verifyKeyServerVersion(response) {
  const keyServerVersion = response.headers.get("X-KeyServer-Version");
  if (keyServerVersion == null) {
    throw new import_error.InvalidKeyServerVersionError("Key server version not found");
  }
  if (new import_utils.Version(keyServerVersion).older_than(SERVER_VERSION_REQUIREMENT)) {
    throw new import_error.InvalidKeyServerVersionError(
      `Key server version ${keyServerVersion} is not supported`
    );
  }
}
class BonehFranklinBLS12381DerivedKey {
  constructor(key) {
    this.key = key;
    this.representation = (0, import_bcs.toHex)(key.toBytes());
  }
  toString() {
    return this.representation;
  }
}
async function fetchKeysForAllIds({
  url,
  requestSignature,
  transactionBytes,
  encKey,
  encKeyPk,
  encVerificationKey,
  certificate,
  timeout,
  apiKeyName,
  apiKey,
  signal
}) {
  const body = {
    ptb: (0, import_bcs.toBase64)(transactionBytes.slice(1)),
    // removes the byte of the transaction type version
    enc_key: (0, import_bcs.toBase64)(encKeyPk),
    enc_verification_key: (0, import_bcs.toBase64)(encVerificationKey),
    request_signature: requestSignature,
    // already b64
    certificate
  };
  const timeoutSignal = AbortSignal.timeout(timeout);
  const combinedSignal = signal ? AbortSignal.any([signal, timeoutSignal]) : timeoutSignal;
  const requestId = crypto.randomUUID();
  const response = await fetch(url + "/v1/fetch_key", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Request-Id": requestId,
      "Client-Sdk-Type": "typescript",
      "Client-Sdk-Version": import_version.PACKAGE_VERSION,
      ...apiKeyName && apiKey ? { [apiKeyName]: apiKey } : {}
    },
    body: JSON.stringify(body),
    signal: combinedSignal
  });
  await import_error.SealAPIError.assertResponse(response, requestId);
  const resp = await response.json();
  verifyKeyServerVersion(response);
  return resp.decryption_keys.map(
    (dk) => ({
      fullId: (0, import_bcs.toHex)(dk.id),
      key: (0, import_elgamal.elgamalDecrypt)(encKey, dk.encrypted_key.map(import_bcs.fromBase64))
    })
  );
}
//# sourceMappingURL=key-server.js.map
